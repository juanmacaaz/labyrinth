<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ReactPhysics3D: reactphysics3d::ContactSolver Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ReactPhysics3DLogo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ReactPhysics3D
   &#160;<span id="projectnumber">0.7.1</span>
   </div>
   <div id="projectbrief">Physics engine library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacereactphysics3d.html">reactphysics3d</a></li><li class="navelem"><a class="el" href="classreactphysics3d_1_1_contact_solver.html">ContactSolver</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classreactphysics3d_1_1_contact_solver-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">reactphysics3d::ContactSolver Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This class represents the contact solver that is used to solve rigid bodies contacts.  
 <a href="classreactphysics3d_1_1_contact_solver.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_contact_solver_8h_source.html">ContactSolver.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a6e5433556a19a0ca10ba4cf26a04b508"><td class="memItemLeft" align="right" valign="top"><a id="a6e5433556a19a0ca10ba4cf26a04b508"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreactphysics3d_1_1_contact_solver.html#a6e5433556a19a0ca10ba4cf26a04b508">ContactSolver</a> (<a class="el" href="classreactphysics3d_1_1_memory_manager.html">MemoryManager</a> &amp;memoryManager, const <a class="el" href="structreactphysics3d_1_1_world_settings.html">WorldSettings</a> &amp;worldSettings)</td></tr>
<tr class="memdesc:a6e5433556a19a0ca10ba4cf26a04b508"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor. <br /></td></tr>
<tr class="separator:a6e5433556a19a0ca10ba4cf26a04b508"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1ae9ae73c1d8d49ba57a0f4003fc025"><td class="memItemLeft" align="right" valign="top"><a id="ab1ae9ae73c1d8d49ba57a0f4003fc025"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreactphysics3d_1_1_contact_solver.html#ab1ae9ae73c1d8d49ba57a0f4003fc025">~ContactSolver</a> ()=default</td></tr>
<tr class="memdesc:ab1ae9ae73c1d8d49ba57a0f4003fc025"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:ab1ae9ae73c1d8d49ba57a0f4003fc025"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9fd7edbbaaace571c5318252e865f8c"><td class="memItemLeft" align="right" valign="top"><a id="ae9fd7edbbaaace571c5318252e865f8c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreactphysics3d_1_1_contact_solver.html#ae9fd7edbbaaace571c5318252e865f8c">init</a> (<a class="el" href="classreactphysics3d_1_1_island.html">Island</a> **islands, uint nbIslands, decimal timeStep)</td></tr>
<tr class="memdesc:ae9fd7edbbaaace571c5318252e865f8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the contact constraints. <br /></td></tr>
<tr class="separator:ae9fd7edbbaaace571c5318252e865f8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc2af9e854d27cbb84ed3b85e4595414"><td class="memItemLeft" align="right" valign="top"><a id="acc2af9e854d27cbb84ed3b85e4595414"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreactphysics3d_1_1_contact_solver.html#acc2af9e854d27cbb84ed3b85e4595414">initializeForIsland</a> (<a class="el" href="classreactphysics3d_1_1_island.html">Island</a> *island)</td></tr>
<tr class="memdesc:acc2af9e854d27cbb84ed3b85e4595414"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the constraint solver for a given island. <br /></td></tr>
<tr class="separator:acc2af9e854d27cbb84ed3b85e4595414"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8f60eb325ecf7955ab41a9c6cbcf317"><td class="memItemLeft" align="right" valign="top"><a id="ab8f60eb325ecf7955ab41a9c6cbcf317"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreactphysics3d_1_1_contact_solver.html#ab8f60eb325ecf7955ab41a9c6cbcf317">setSplitVelocitiesArrays</a> (<a class="el" href="structreactphysics3d_1_1_vector3.html">Vector3</a> *splitLinearVelocities, <a class="el" href="structreactphysics3d_1_1_vector3.html">Vector3</a> *splitAngularVelocities)</td></tr>
<tr class="memdesc:ab8f60eb325ecf7955ab41a9c6cbcf317"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classreactphysics3d_1_1_set.html" title="This class represents a simple generic set. ">Set</a> the split velocities arrays. <br /></td></tr>
<tr class="separator:ab8f60eb325ecf7955ab41a9c6cbcf317"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa13b4fd602a38288bcfd3c1a7b747090"><td class="memItemLeft" align="right" valign="top"><a id="aa13b4fd602a38288bcfd3c1a7b747090"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreactphysics3d_1_1_contact_solver.html#aa13b4fd602a38288bcfd3c1a7b747090">setConstrainedVelocitiesArrays</a> (<a class="el" href="structreactphysics3d_1_1_vector3.html">Vector3</a> *constrainedLinearVelocities, <a class="el" href="structreactphysics3d_1_1_vector3.html">Vector3</a> *constrainedAngularVelocities)</td></tr>
<tr class="memdesc:aa13b4fd602a38288bcfd3c1a7b747090"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classreactphysics3d_1_1_set.html" title="This class represents a simple generic set. ">Set</a> the constrained velocities arrays. <br /></td></tr>
<tr class="separator:aa13b4fd602a38288bcfd3c1a7b747090"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2937654b82685dc29ebeec3a66b0fab7"><td class="memItemLeft" align="right" valign="top"><a id="a2937654b82685dc29ebeec3a66b0fab7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreactphysics3d_1_1_contact_solver.html#a2937654b82685dc29ebeec3a66b0fab7">storeImpulses</a> ()</td></tr>
<tr class="memdesc:a2937654b82685dc29ebeec3a66b0fab7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store the computed impulses to use them to warm start the solver at the next iteration. <br /></td></tr>
<tr class="separator:a2937654b82685dc29ebeec3a66b0fab7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3813b33e92f04221b78b629e3307113c"><td class="memItemLeft" align="right" valign="top"><a id="a3813b33e92f04221b78b629e3307113c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreactphysics3d_1_1_contact_solver.html#a3813b33e92f04221b78b629e3307113c">solve</a> ()</td></tr>
<tr class="memdesc:a3813b33e92f04221b78b629e3307113c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve the contacts. <br /></td></tr>
<tr class="separator:a3813b33e92f04221b78b629e3307113c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30968af274a76095b70b53d5b5bd148a"><td class="memItemLeft" align="right" valign="top"><a id="a30968af274a76095b70b53d5b5bd148a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreactphysics3d_1_1_contact_solver.html#a30968af274a76095b70b53d5b5bd148a">isSplitImpulseActive</a> () const</td></tr>
<tr class="memdesc:a30968af274a76095b70b53d5b5bd148a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the split impulses position correction technique is used for contacts. <br /></td></tr>
<tr class="separator:a30968af274a76095b70b53d5b5bd148a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8073504f72ae942433e510ddd879361"><td class="memItemLeft" align="right" valign="top"><a id="ad8073504f72ae942433e510ddd879361"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreactphysics3d_1_1_contact_solver.html#ad8073504f72ae942433e510ddd879361">setIsSplitImpulseActive</a> (bool isActive)</td></tr>
<tr class="memdesc:ad8073504f72ae942433e510ddd879361"><td class="mdescLeft">&#160;</td><td class="mdescRight">Activate or Deactivate the split impulses for contacts. <br /></td></tr>
<tr class="separator:ad8073504f72ae942433e510ddd879361"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This class represents the contact solver that is used to solve rigid bodies contacts. </p>
<p>The constraint solver is based on the "Sequential Impulse" technique described by Erin Catto in his GDC slides (<a href="http://code.google.com/p/box2d/downloads/list">http://code.google.com/p/box2d/downloads/list</a>).</p>
<p>A constraint between two bodies is represented by a function C(x) which is equal to zero when the constraint is satisfied. The condition C(x)=0 describes a valid position and the condition dC(x)/dt=0 describes a valid velocity. We have dC(x)/dt = Jv + b = 0 where J is the Jacobian matrix of the constraint, v is a vector that contains the velocity of both bodies and b is the constraint bias. We are looking for a force F_c that will act on the bodies to keep the constraint satisfied. Note that from the virtual work principle, we have F_c = J^t * lambda where J^t is the transpose of the Jacobian matrix and lambda is a Lagrange multiplier. Therefore, finding the force F_c is equivalent to finding the Lagrange multiplier lambda.</p>
<p>An impulse P = F * dt where F is a force and dt is the timestep. We can apply impulses a body to change its velocity. The idea of the Sequential Impulse technique is to apply impulses to bodies of each constraints in order to keep the constraint satisfied.</p>
<p>&mdash; Step 1 &mdash;</p>
<p>First, we integrate the applied force F_a acting of each rigid body (like gravity, ...) and we obtain some new velocities v2' that tends to violate the constraints.</p>
<p>v2' = v1 + dt * M^-1 * F_a</p>
<p>where M is a matrix that contains mass and inertia tensor information.</p>
<p>&mdash; Step 2 &mdash;</p>
<p>During the second step, we iterate over all the constraints for a certain number of iterations and for each constraint we compute the impulse to apply to the bodies needed so that the new velocity of the bodies satisfy Jv + b = 0. From the Newton law, we know that M * deltaV = P_c where M is the mass of the body, deltaV is the difference of velocity and P_c is the constraint impulse to apply to the body. Therefore, we have v2 = v2' + M^-1 * P_c. For each constraint, we can compute the Lagrange multiplier lambda using : lambda = -m_c (Jv2' + b) where m_c = 1 / (J * M^-1 * J^t). Now that we have the Lagrange multiplier lambda, we can compute the impulse P_c = J^t * lambda * dt to apply to the bodies to satisfy the constraint.</p>
<p>&mdash; Step 3 &mdash;</p>
<p>In the third step, we integrate the new position x2 of the bodies using the new velocities v2 computed in the second step with : x2 = x1 + dt * v2.</p>
<p>Note that in the following code (as it is also explained in the slides from Erin Catto), the value lambda is not only the lagrange multiplier but is the multiplication of the Lagrange multiplier with the timestep dt. Therefore, in the following code, when we use lambda, we mean (lambda * dt).</p>
<p>We are using the accumulated impulse technique that is also described in the slides from Erin Catto.</p>
<p>We are also using warm starting. The idea is to warm start the solver at the beginning of each step by applying the last impulstes for the constraints that we already existing at the previous step. This allows the iterative solver to converge faster towards the solution.</p>
<p>For contact constraints, we are also using split impulses so that the position correction that uses Baumgarte stabilization does not change the momentum of the bodies.</p>
<p>There are two ways to apply the friction constraints. Either the friction constraints are applied at each contact point or they are applied only at the center of the contact manifold between two bodies. If we solve the friction constraints at each contact point, we need two constraints (two tangential friction directions) and if we solve the friction constraints at the center of the contact manifold, we need two constraints for tangential friction but also another twist friction constraint to prevent spin of the body around the contact manifold center. </p>
</div><hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/daniel/Development/Git/reactphysics3d/src/engine/<a class="el" href="_contact_solver_8h_source.html">ContactSolver.h</a></li>
<li>/home/daniel/Development/Git/reactphysics3d/src/engine/ContactSolver.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Jun 28 2019 08:19:45 for ReactPhysics3D by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
